--EJERCICIO1
SELECT 57
    EJERCICIO1
FROM DUAL;
--EJERCICIO2
SELECT SQRT(23)
    EJERCICIO2
FROM DUAL;
--EJERCICIO3
SELECT REPLACE(TO_CHAR(TRUNC(SQRT(23),3)), '.',',')
    EJERCICIO3
FROM DUAL;
--EJERCICIO4
SELECT NOMBRE, UPPER(SUBSTR(NOMBRE,-3)) AS TRESLETRAS
FROM ALUMNOS
ORDER BY TRESLETRAS DESC;
--EJERCICIO5
SELECT NIF, NOMBRE, APELLIDO1, APELLIDO2, DIRECCION,
        ((SUBSTR(TELEFONO,0,3)||' ')||(SUBSTR(TELEFONO,4,3)||' ')||(SUBSTR(TELEFONO,-3)||' ')) AS TELEFONO,
       EDAD, CIF, EMAIL
FROM ALUMNOS
ORDER BY APELLIDO1,APELLIDO2,NOMBRE;
--EJERCICIO6
SELECT N_CURSO, ADD_MONTHS(FECHA_INICIO,1) AS FECHA_INICIO,ADD_MONTHS(FECHA_FIN,1) AS FECHA_FIN,COD_CURSO,NIF_PROFESOR
FROM CURSOS;
--EJERCICIO7
SELECT N_CURSO, (FECHA_INICIO+INTERVAL'45' MINUTE)AS FECHA_INICIO,(FECHA_FIN+INTERVAL'45'MINUTE)AS FECHA_FIN,COD_CURSO,NIF_PROFESOR
FROM CURSOS;
--EJERCICIO8
SELECT N_CURSO, FECHA_INICIO,FECHA_FIN,EXTRACT(DAY FROM FECHA_FIN-FECHA_INICIO) AS DIAS
FROM CURSOS;
--EJERCICIO9
SELECT N_CURSO,TO_CHAR(FECHA_INICIO, 'fmDAY dd "de" Month "del" yyyy, hh":"mi AM'),FECHA_FIN,EXTRACT(DAY FROM FECHA_FIN-FECHA_INICIO) AS DIAS
FROM CURSOS;
--EJERCICIO10
SELECT (LAST_DAY(SYSDATE))
FROM DUAL;
--EJERCICIO 18
SELECT DIRECCION, SUBSTR(DIRECCION, 1, INSTR(DIRECCION, ' ')-1) TIPO_VIA
FROM ALUMNOS;
--EJERCICIO 18.2
SELECT DIRECCION,TRIM(REGEXP_SUBSTR(DIRECCION, '^[[:alpha:]]+ '))
FROM ALUMNOS;
SELECT DIRECCION, REGEXP_SUBSTR(DIRECCION, '([0-9]+)|(s/n)$') NÚMERO
FROM ALUMNOS;
--ESTA EXPRESIÓN REGULAR NOS INDICA UN NÚMERO O MÁS ([0-9]+) O | s/n (s/n) AL FINAL DEL DATO $.
SELECT DIRECCION, REPLACE(DIRECCION, REGEXP_SUBSTR(DIRECCION, ' ([0-9]+)|(s/n)$')) CALLE
FROM ALUMNOS;
--SE AÑADE UN ESPACIO AL INICIO DE LA EXPRESIÓN REGULAR PARA QUE EL REPLACE LE QUITE
--EJERCICIO20
SELECT NOMBRE, APELLIDO1, APELLIDO2,
        UPPER(
            REGEXP_REPLACE(UPPER(APELLIDO1), '[AEIOUÁÉÍÓÚÜ]')||
            SUBSTR(APELLIDO2,1,3)||SUBSTR(NOMBRE,1,1)
            ) NOMBRE_USUARIO

FROM ALUMNOS
ORDER BY NOMBRE_USUARIO;
--REGEXP_REPLACE PERMITE ESXPRESIONES REGULARES, REPLACE NO

--EJERCICIO20 SIN EXPRESIONES REGULARES
SELECT NOMBRE, APELLIDO1, APELLIDO2,
        UPPER(
                REPLACE(
                        TRANSLATE(UPPER(APELLIDO1), 'AEIOUÁÉÍÓÚÜ', '**********'),'*'
                    )||
                            SUBSTR(APELLIDO2, 1, 3) || SUBSTR(NOMBRE, 1, 1)
            )NOMBRE_USUARIO

FROM ALUMNOS
ORDER BY NOMBRE_USUARIO;
--TRANSLETE CAMBIA LAS VOCALES POR ASTERICOS Y REPLACE QUITA LOS ASTERISCOS '*', LOS SUTITUYE POR NADA

SELECT NOMBRE,APELLIDO1,APELLIDO2,
       REGEXP_COUNT(UPPER(NOMBRE||APELLIDO1||APELLIDO2),'[ÁÉÍÓÚ]') N_TILDES
FROM ALUMNOS;
--REGEXP_COUNT CUENTA EL NÚMERO DE VECES QUE PASA ALGO, EN ESTE CASO EL NÚMERO DE VECES QUE APARECE UNA LETRA (POR ESO LOS CORCHETES) DE LA EXPRESIÓN REGULAR

SELECT NOMBRE, APELLIDO1, APELLIDO1,
    CASE
        SUBSTR(TELEFONO,1,1)
        WHEN '6' THEN 'Móvil'
        WHEN '7' THEN 'Móvil'
        WHEN '9' THEN 'Fijo'
        ELSE 'SIN TELEFONO'
    END

FROM ALUMNOS;

--VERSIÓN2
SELECT NOMBRE, APELLIDO1, APELLIDO1,
    CASE
        WHEN TELEFONO LIKE '6%' THEN 'Móvil'
        WHEN TELEFONO LIKE '7%' THEN 'Móvil'
        WHEN TELEFONO LIKE '9%' THEN 'Fijo'
        ELSE 'Sin telefono'
    END
FROM ALUMNOS;

SELECT NOMBRE, APELLIDO1, APELLIDO2, TELEFONO,
    DECODE(SUBSTR(TELEFONO, 1, 1),
           '6', 'Móvil',
           '7', 'Móvil',
           '9', 'Fijo',
           'Sin telefono'
        )
FROM ALUMNOS;
--DECODE FUNCIONA COMO UN CASE MÁS COMPACTO PERO MENOS POTENTE
--COMPRUEBA SI LO INTRODUCIDO ENTRE PARENTESIS (SUBSTR) ES IGUAL AL VALOR INDICADO ('6'), SI ES CIERTO DEVUELVE EL SEGUNDO ('MOVIL')

SELECT CASE EXTRACT(DAY FROM
            LAST_DAY(TO_DATE('1/2/'||EXTRACT(YEAR FROM SYSDATE),'DD/MM/YYYY'))
            )
            WHEN 29 THEN 'Bisiesto'
            ELSE 'No es bisisesto'
        END

FROM DUAL;

SELECT CASE
    WHEN MOD(EXTRACT(YEAR FROM SYSDATE),400)=0 OR
         (NOT MOD(EXTRACT(YEAR FROM SYSDATE),100)=0 AND
          MOD(EXTRACT(YEAR FROM SYSDATE),4)=0
             )
            THEN 'BISIESTO'
            ELSE 'NO ES BISIESTO'
        END
AS BISIESTO
FROM DUAL;

--mod, case, decode, like...