SELECT DIRECCION, REGEXP_SUBSTR(DIRECCION, '([0-9]+)|(s/n)$') NÚMERO
FROM ALUMNOS;
--ESTA EXPRESIÓN REGULAR NOS INDICA UN NÚMERO O MÁS ([0-9]+) O | s/n (s/n) AL FINAL DEL DATO $.
SELECT DIRECCION, REPLACE(DIRECCION, REGEXP_SUBSTR(DIRECCION, ' ([0-9]+)|(s/n)$')) CALLE
FROM ALUMNOS;
--SE AÑADE UN ESPACIO AL INICIO DE LA EXPRESIÓN REGULAR PARA QUE EL REPLACE LE QUITE
--EJERCICIO20
SELECT NOMBRE, APELLIDO1, APELLIDO2,
        UPPER(
            REGEXP_REPLACE(UPPER(APELLIDO1), '[AEIOUÁÉÍÓÚÜ]')||
            SUBSTR(APELLIDO2,1,3)||SUBSTR(NOMBRE,1,1)
            ) NOMBRE_USUARIO

FROM ALUMNOS
ORDER BY NOMBRE_USUARIO;
--REGEXP_REPLACE PERMITE ESXPRESIONES REGULARES, REPLACE NO

--EJERCICIO20 SIN EXPRESIONES REGULARES
SELECT NOMBRE, APELLIDO1, APELLIDO2,
        UPPER(
                REPLACE(
                        TRANSLATE(UPPER(APELLIDO1), 'AEIOUÁÉÍÓÚÜ', '**********'),'*'
                    )||
                            SUBSTR(APELLIDO2, 1, 3) || SUBSTR(NOMBRE, 1, 1)
            )NOMBRE_USUARIO

FROM ALUMNOS
ORDER BY NOMBRE_USUARIO;
--TRANSLETE CAMBIA LAS VOCALES POR ASTERICOS Y REPLACE QUITA LOS ASTERISCOS '*', LOS SUTITUYE POR NADA

SELECT NOMBRE,APELLIDO1,APELLIDO2,
       REGEXP_COUNT(UPPER(NOMBRE||APELLIDO1||APELLIDO2),'[ÁÉÍÓÚ]') N_TILDES
FROM ALUMNOS;
--REGEXP_COUNT CUENTA EL NÚMERO DE VECES QUE PASA ALGO, EN ESTE CASO EL NÚMERO DE VECES QUE APARECE UNA LETRA (POR ESO LOS CORCHETES) DE LA EXPRESIÓN REGULAR

SELECT NOMBRE, APELLIDO1, APELLIDO1,
    CASE
        SUBSTR(TELEFONO,1,1)
        WHEN '6' THEN 'Móvil'
        WHEN '7' THEN 'Móvil'
        WHEN '9' THEN 'Fijo'
        ELSE 'SIN TELEFONO'
    END

FROM ALUMNOS;

--VERSIÓN2
SELECT NOMBRE, APELLIDO1, APELLIDO1,
    CASE
        WHEN TELEFONO LIKE '6%' THEN 'Móvil'
        WHEN TELEFONO LIKE '7%' THEN 'Móvil'
        WHEN TELEFONO LIKE '9%' THEN 'Fijo'
        ELSE 'Sin telefono'
    END
FROM ALUMNOS;

SELECT NOMBRE, APELLIDO1, APELLIDO1,
    DECODE(SUBSTR(TELEFONO, 1, 1),
           '6', 'Móvil',
           '7', 'Móvil',
           '9', 'Fijo',
           'Sin telefono'
        )
FROM ALUMNOS;
--DECODE FUNCIONA COMO UN CASE MÁS COMPACTO PERO MENOS POTENTE
--COMPRUEBA SI LO INTRODUCIDO ENTRE PARENTESIS (SUBSTR) ES IGUAL AL VALOR INDICADO ('6'), SI ES CIERTO DEVUELVE EL SEGUNDO ('MOVIL')

SELECT CASE EXTRACT(DAY FROM
            LAST_DAY(TO_DATE('1/2/'||EXTRACT(YEAR FROM SYSDATE),'DD/MM/YYYY'))
            )
            WHEN 29 THEN 'Bisiesto'
            ELSE 'No es bisisesto'
        END

FROM DUAL;
